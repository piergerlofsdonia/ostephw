#### Notes on chapter 13: "The Abstraction: Address Spaces"
In earlier systems, the physical memory was accessible to the user, the operating system and user applications operated within different address spaces within physical memory (e.g. operating system subroutines sitting in memory starting at address 0 and user programs sitting in memory starting at address 64k). Without virtualisation, time-sharing systems operated on a crude system of storing and restoring program states including physical memory when each process was run, resulting in general inefficiency and long wait times due to the slowness of this approach (particularly when a process is utilising more and more memory).

A different approach is required in order to achieve faster swap times between processes. Rather than having a single address space for user processes, having a separate section of memory for each process negates much of the need to store a process's physical memory onto the disk, instead swapping the address space. An (virtual) address space is a section of memory addressed from 0 to _max_ in which the memory segments of the process sit. An example is given within _OSTEP (p. 123)_ showing the _code_ section, the _stack_ and the _heap_, and the boundary between each section, the stack and heap is shown to have a void between them in which they are allowed to grow. This diagram is omitted in these notes due to it being a drastic oversimplification. This address space can be thought of as an abstraction of physical memory addressing provided by the operating system - it works to keep process memory separated. Separating processes is the operating systems method of ensuring the operating system and kernel are protected from malicious processes as well as keeping a process from actively or accidentally editing the memory stored in another process's address space.

The addresses given above as the start addresses of each address space are _virtual_ addresses, that is, the address used within the confines of the process - by the programmer and potentially by the user. The _actual_ address is the physical address in which that data is stored, this gives the illusion that the process has its own private physical address space. To a programmer, there is only _virtual_ memory, the operating system manages the abstraction between _virtual_ memory addresses and physical ones (e.g. if you print a pointer `printf("%p\n", (void *) malloc(1));` within a program, this is a virtual address). The main goal of the operating system in virtualising memory is to provide this illusion, i.e. it is a _transparent_ system to the end-user. Additionally the operating system does this efficiently, without using more time or space than needed for the data being stored.

